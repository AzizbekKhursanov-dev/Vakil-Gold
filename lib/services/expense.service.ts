import {
  collection,
  addDoc,
  updateDoc,
  deleteDoc,
  doc,
  query,
  where,
  orderBy,
  getDocs,
  writeBatch,
  serverTimestamp,
} from "firebase/firestore"
import { db } from "@/lib/config/firebase"

export interface EnhancedExpense {
  id?: string
  category: string
  subcategory?: string
  amount: number
  description: string
  date: string
  branchId?: string
  branchName?: string
  paymentMethod: string
  reference?: string
  notes?: string
  status: "draft" | "pending" | "approved" | "paid" | "rejected" | "cancelled"
  priority: "low" | "medium" | "high" | "urgent"
  approvalLevel: number
  approvedBy?: string[]
  approvedAt?: string
  rejectedBy?: string
  rejectedAt?: string
  rejectionReason?: string
  createdBy: string
  createdAt: string
  updatedAt: string

  // Enhanced fields
  isRecurring?: boolean
  recurringFrequency?: "weekly" | "monthly" | "quarterly" | "yearly"
  nextDueDate?: string
  attachments?: string[]
  relatedItemIds?: string[]
  relatedSupplierTransactionId?: string
  budgetCategory?: string
  costCenter?: string
  taxAmount?: number
  vatAmount?: number
  isReimbursable?: boolean
  employeeId?: string
  projectId?: string

  // Integration fields
  connectedToSupplierPayment?: boolean
  connectedToItemPurchase?: boolean
  autoGenerated?: boolean
  sourceType?: "manual" | "supplier_payment" | "item_purchase" | "recurring" | "import"
}

class ExpenseService {
  private collectionName = "expenses"

  // Create new expense
  async createExpense(data: Omit<EnhancedExpense, "id" | "createdAt" | "updatedAt">): Promise<string> {
    try {
      const expenseData = {
        ...data,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      }

      const docRef = await addDoc(collection(db, this.collectionName), expenseData)
      return docRef.id
    } catch (error) {
      console.error("Error creating expense:", error)
      throw new Error("Failed to create expense")
    }
  }

  // Update expense
  async updateExpense(id: string, data: Partial<EnhancedExpense>): Promise<void> {
    try {
      await updateDoc(doc(db, this.collectionName, id), {
        ...data,
        updatedAt: serverTimestamp(),
      })
    } catch (error) {
      console.error("Error updating expense:", error)
      throw new Error("Failed to update expense")
    }
  }

  // Delete expense
  async deleteExpense(id: string): Promise<void> {
    try {
      await deleteDoc(doc(db, this.collectionName, id))
    } catch (error) {
      console.error("Error deleting expense:", error)
      throw new Error("Failed to delete expense")
    }
  }

  // Approve expense
  async approveExpense(id: string, approvedBy: string, comments?: string): Promise<void> {
    try {
      const updateData: any = {
        status: "approved",
        approvedAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      }

      // Add to approved by array
      updateData.approvedBy = [approvedBy] // In real app, you'd append to existing array

      if (comments) {
        updateData.approvalComments = updateData.approvalComments || []
        updateData.approvalComments.push({
          comment: comments,
          by: approvedBy,
          date: new Date().toISOString(),
          action: "approve",
        })
      }

      await updateDoc(doc(db, this.collectionName, id), updateData)
    } catch (error) {
      console.error("Error approving expense:", error)
      throw new Error("Failed to approve expense")
    }
  }

  // Reject expense
  async rejectExpense(id: string, rejectedBy: string, reason: string): Promise<void> {
    try {
      await updateDoc(doc(db, this.collectionName, id), {
        status: "rejected",
        rejectedBy,
        rejectedAt: serverTimestamp(),
        rejectionReason: reason,
        updatedAt: serverTimestamp(),
      })
    } catch (error) {
      console.error("Error rejecting expense:", error)
      throw new Error("Failed to reject expense")
    }
  }

  // Generate expenses from supplier payments
  async generateExpensesFromSupplierPayments(supplierTransactions: any[]): Promise<number> {
    try {
      const batch = writeBatch(db)
      let generated = 0

      // Get existing expenses to avoid duplicates
      const existingExpensesQuery = query(
        collection(db, this.collectionName),
        where("sourceType", "==", "supplier_payment"),
      )
      const existingExpenses = await getDocs(existingExpensesQuery)
      const existingTransactionIds = new Set(
        existingExpenses.docs.map((doc) => doc.data().relatedSupplierTransactionId),
      )

      for (const transaction of supplierTransactions) {
        if (existingTransactionIds.has(transaction.id)) continue

        const expenseData: Omit<EnhancedExpense, "id"> = {
          category: "Ta'minotchi to'lovlari",
          subcategory: "Mahsulot xaridi",
          amount: transaction.totalAmount,
          description: `${transaction.supplierName}ga to'lov - ${transaction.itemIds?.length || 0} ta mahsulot`,
          date: transaction.paymentDate || transaction.transactionDate,
          paymentMethod: "Bank o'tkazmasi",
          reference: transaction.reference || `ST-${transaction.id.slice(-6)}`,
          status: "paid",
          priority: "medium",
          approvalLevel: 3,
          autoGenerated: true,
          sourceType: "supplier_payment",
          relatedSupplierTransactionId: transaction.id,
          relatedItemIds: transaction.itemIds || [],
          connectedToSupplierPayment: true,
          createdBy: "system",
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          notes: `Avtomatik yaratilgan - Ta'minotchi: ${transaction.supplierName}`,
        }

        const docRef = doc(collection(db, this.collectionName))
        batch.set(docRef, {
          ...expenseData,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
        })
        generated++
      }

      if (generated > 0) {
        await batch.commit()
      }

      return generated
    } catch (error) {
      console.error("Error generating expenses from supplier payments:", error)
      throw new Error("Failed to generate expenses from supplier payments")
    }
  }

  // Generate expenses from item purchases
  async generateExpensesFromItemPurchases(items: any[]): Promise<number> {
    try {
      const batch = writeBatch(db)
      let generated = 0

      // Group items by supplier and purchase date
      const itemGroups: Record<string, any[]> = {}
      items.forEach((item) => {
        if (item.supplierName && item.purchaseDate) {
          const key = `${item.supplierName}-${item.purchaseDate}`
          if (!itemGroups[key]) {
            itemGroups[key] = []
          }
          itemGroups[key].push(item)
        }
      })

      // Get existing expenses to avoid duplicates
      const existingExpensesQuery = query(
        collection(db, this.collectionName),
        where("sourceType", "==", "item_purchase"),
      )
      const existingExpenses = await getDocs(existingExpensesQuery)
      const existingItemIds = new Set()
      existingExpenses.docs.forEach((doc) => {
        const data = doc.data()
        if (data.relatedItemIds) {
          data.relatedItemIds.forEach((id: string) => existingItemIds.add(id))
        }
      })

      for (const [key, groupItems] of Object.entries(itemGroups)) {
        // Check if any items in this group already have expenses
        const hasExistingExpense = groupItems.some((item) => existingItemIds.has(item.id))
        if (hasExistingExpense) continue

        const totalAmount = groupItems.reduce((sum, item) => sum + item.weight * item.lomNarxi, 0)
        const supplierName = groupItems[0].supplierName
        const purchaseDate = groupItems[0].purchaseDate

        const expenseData: Omit<EnhancedExpense, "id"> = {
          category: "Mahsulot xaridi",
          subcategory: "Tilla mahsulotlari",
          amount: totalAmount,
          description: `${supplierName}dan mahsulot xaridi - ${groupItems.length} ta mahsulot`,
          date: purchaseDate,
          paymentMethod: "Bank o'tkazmasi",
          reference: `IP-${Date.now().toString().slice(-6)}`,
          status: "pending",
          priority: "medium",
          approvalLevel: 0,
          autoGenerated: true,
          sourceType: "item_purchase",
          relatedItemIds: groupItems.map((item) => item.id),
          connectedToItemPurchase: true,
          createdBy: "system",
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          notes: `Avtomatik yaratilgan - ${groupItems.length} ta mahsulot, Jami og'irlik: ${groupItems.reduce((sum: number, item: any) => sum + item.weight, 0).toFixed(2)}g`,
        }

        const docRef = doc(collection(db, this.collectionName))
        batch.set(docRef, {
          ...expenseData,
          createdAt: serverTimestamp(),
          updatedAt: serverTimestamp(),
        })
        generated++
      }

      if (generated > 0) {
        await batch.commit()
      }

      return generated
    } catch (error) {
      console.error("Error generating expenses from item purchases:", error)
      throw new Error("Failed to generate expenses from item purchases")
    }
  }

  // Get expenses by category
  async getExpensesByCategory(category: string): Promise<EnhancedExpense[]> {
    try {
      const q = query(collection(db, this.collectionName), where("category", "==", category), orderBy("date", "desc"))
      const querySnapshot = await getDocs(q)

      return querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt?.toDate?.()?.toISOString() || doc.data().createdAt,
        updatedAt: doc.data().updatedAt?.toDate?.()?.toISOString() || doc.data().updatedAt,
      })) as EnhancedExpense[]
    } catch (error) {
      console.error("Error getting expenses by category:", error)
      throw new Error("Failed to get expenses by category")
    }
  }

  // Get pending expenses for approval
  async getPendingExpenses(): Promise<EnhancedExpense[]> {
    try {
      const q = query(
        collection(db, this.collectionName),
        where("status", "==", "pending"),
        orderBy("priority", "desc"),
        orderBy("date", "desc"),
      )
      const querySnapshot = await getDocs(q)

      return querySnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
        createdAt: doc.data().createdAt?.toDate?.()?.toISOString() || doc.data().createdAt,
        updatedAt: doc.data().updatedAt?.toDate?.()?.toISOString() || doc.data().updatedAt,
      })) as EnhancedExpense[]
    } catch (error) {
      console.error("Error getting pending expenses:", error)
      throw new Error("Failed to get pending expenses")
    }
  }

  // Get expense statistics
  async getExpenseStats(
    startDate?: string,
    endDate?: string,
  ): Promise<{
    totalExpenses: number
    totalAmount: number
    pendingAmount: number
    approvedAmount: number
    paidAmount: number
    rejectedAmount: number
    byCategory: Record<string, number>
    byStatus: Record<string, number>
  }> {
    try {
      let q = query(collection(db, this.collectionName))

      if (startDate && endDate) {
        q = query(collection(db, this.collectionName), where("date", ">=", startDate), where("date", "<=", endDate))
      }

      const querySnapshot = await getDocs(q)
      const expenses = querySnapshot.docs.map((doc) => doc.data()) as EnhancedExpense[]

      const stats = {
        totalExpenses: expenses.length,
        totalAmount: expenses.reduce((sum, exp) => sum + exp.amount, 0),
        pendingAmount: expenses.filter((e) => e.status === "pending").reduce((sum, exp) => sum + exp.amount, 0),
        approvedAmount: expenses.filter((e) => e.status === "approved").reduce((sum, exp) => sum + exp.amount, 0),
        paidAmount: expenses.filter((e) => e.status === "paid").reduce((sum, exp) => sum + exp.amount, 0),
        rejectedAmount: expenses.filter((e) => e.status === "rejected").reduce((sum, exp) => sum + exp.amount, 0),
        byCategory: {} as Record<string, number>,
        byStatus: {} as Record<string, number>,
      }

      // Calculate by category
      expenses.forEach((expense) => {
        stats.byCategory[expense.category] = (stats.byCategory[expense.category] || 0) + expense.amount
        stats.byStatus[expense.status] = (stats.byStatus[expense.status] || 0) + expense.amount
      })

      return stats
    } catch (error) {
      console.error("Error getting expense stats:", error)
      throw new Error("Failed to get expense statistics")
    }
  }
}

export const expenseService = new ExpenseService()
